++++++++++++++++++++++++++++++++++++++++++++++++
Generic Secure Timer aarch64
++++++++++++++++++++++++++++++++++++++++++++++++
\optee_os-master\core\arch\arm\kernel\generic_boot.c
-> __weak void generic_s_timer_start(void){}
-> generic_s_timer_start();

\optee_os-master\core\arch\arm\plat-vexpress\main.c
-> void generic_s_timer_start(void){}
-> #ifdef IT_SECURE_TIMER {...} #endif

\optee_os-master\core\arch\arm\include\kernel\generic_boot.h
-> void generic_s_timer_start(void);

\optee_os-master\core\arch\arm\include\arm64.h
-> DEFINE_U64_REG_READ_FUNC(cntpct_el0)
-> DEFINE_U64_REG_READ_FUNC(cntfrq_el0)
-> DEFINE_U64_REG_READ_FUNC(cntps_ctl_el1)
-> DEFINE_U64_REG_WRITE_FUNC(cntps_cval_el1)
-> DEFINE_U64_REG_WRITE_FUNC(cntps_ctl_el1)

\optee_os-master\core\arch\arm\plat-vexpress\platform_config.h
-> #define IT_SECURE_TIMER 29

++++++++++++++++++++++++++++++++++++++++++++++++
Generic Secure Timer aarch32
++++++++++++++++++++++++++++++++++++++++++++++++
\optee_os-master\core\arch\arm\include\arm32.h
-> static inline void write_cntp_cval(uint64_t cval)
-> static inline void write_cntfrq(uint32_t frq)
-> static inline uint32_t read_cntp_ctl(void)

++++++++++++++++++++++++++++++++++++++++++++++++
Static TA
++++++++++++++++++++++++++++++++++++++++++++++++
\optee_os-master\core\arch\arm\pta\
+ sta_filter.c
~\sub.mk
-> #srcs-$(CFG_TEE_CORE_EMBED_INTERNAL_TESTS) += sta_filter.c

\linux-optee\drivers\tee
+ tee_core_cp.c
+ tee_core_extern.h
+ tee_client_api.c

~\Makefile
-> tee-objs += tee_core_cp.o
-> tee-objs += tee_client_api.o

\linux-optee\drivers\tee\optee
+ tee_filter.c

~\Makefile
-> optee-objs += tee_filter.o

\linux-optee\drivers\tee\optee\core.c
-> //void tee_filter(struct tee_device *teedev);
-> //tee_filter(optee->teedev);

\linux-optee\include\linux\
+ tee_client_api.h

++++++++++++++++++++++++++++++++++++++++++++++++
Dynamic TA
++++++++++++++++++++++++++++++++++++++++++++++++
\hello_world\ta\hello_world_ta.c
-> static void test_cpu(void){}
-> test_cpu();

++++++++++++++++++++++++++++++++++++++++++++++++
Static TA : test_idle
++++++++++++++++++++++++++++++++++++++++++++++++
\optee_os\core\arch\arm\pta\
+ test_idle.c

~\sub.mk
-> srcs-$(CFG_TEE_CORE_EMBED_INTERNAL_TESTS) += test_idle.c

\hello_world\ta\include\hello_world_ta.h
-> #define STA_TEST_IDLE_UUID

\hello_world\host\main.c
-> TEEC_UUID uuid = STA_TEST_IDLE_UUID;
-> res = TEEC_InvokeCommand(&sess, 163, &op, &err_origin);

++++++++++++++++++++++++++++++++++++++++++++++++
optee_os aarch32
++++++++++++++++++++++++++++++++++++++++++++++++
\build\Makefile
-> COMPILE_S_USER  ?= 32
-> COMPILE_S_KERNEL ?= 32

++++++++++++++++++++++++++++++++++++++++++++++++
expand optee with minix
++++++++++++++++++++++++++++++++++++++++++++++++
\optee_os\core\include\drivers\
+ rtos_bsp_intr.h

\optee_os\core\drivers\
+ rtos_bsp_intr.c

\optee_os\core\drivers\gic.c
-> void gic_it_enable (remove static)
-> void gic_it_disable (remove static)
-> void gic_it_add (remove static)
-> irq_handle(id);

\optee_os\core\include\drivers\gic.h
-> void gic_it_enable(struct gic_data *gd, size_t it);
-> void gic_it_disable(struct gic_data *gd, size_t it);
-> void gic_it_add(struct gic_data *gd, size_t it);

\optee_os\core\arch\arm\kernel\generic_boot.c
-> intr_init();
-> static void intr_init(void){}

\optee_os\core\include\kernel\
+ rtos_type.h
+ rtos_interrupt.h
+ rtos_glo.h

\optee_os\core\kernel\
+ rtos_interrupt.c

\optee_os\core\drivers\sub.mk
-> srcs-$(CFG_GIC) += rtos_bsp_intr.c

\optee_os\core\kernel\sub.mk
-> srcs-y += rtos_interrupt.c

\optee_os\core\arch\arm\plat-vexpress\main.c
-> struct gic_data gic_data; (remove static)
-> #ifdef IT_SECURE_TIMER {} #endif
-> #ifdef OLD_IT_SECURE_TIMER {} #endif
-> #ifdef IT_CONSOLE_UART {} #endif
-> #ifdef OLD_IT_CONSOLE_UART {} #endif

++++++++++++++++++++++++++++++++++++++++++++++++
optee monotonic time
++++++++++++++++++++++++++++++++++++++++++++++++
\optee_os\core\include\
+ rtos_jiffies.h
+ rtos_time.h
+ rtos_timer.h
+ rtos_list.h
+ rtos_percpu.h
+ rtos_poison.h
+ rtos_hardfiq.h
+ rtos_fiq_cpustat.h

\optee_os\core\kernel\
+ rtos_time.c
+ rtos_timer.c
+ rtos_softfiq.c
+ rtos_hardfiq.c

\optee_os\core\kernel\sub.mk
-> srcs-y += rtos_time.c
-> srcs-y += rtos_timer.c
-> srcs-y += rtos_softfiq.c
-> srcs-y += rtos_hardfiq.c

\optee_os\core\arch\arm\plat-vexpress\main.c
-> #ifdef IT_SECURE_TIMER {...} #endif
-> static void restart_s_timer(void);
-> #include <rtos_timer.h>
-> static void mytimer(void);
-> static void myfunction(unsigned long data);
-> mytimer();
-> uint32_t n;
-> struct timer_list timer1;
-> struct timer_list timer2;
-> struct timer_list timer3;
-> struct timer_list timer4;
-> struct timer_list timer5;
-> struct timer_list timer6;

\optee_os\core\include\kernel\interrupt.h
-> enum { TIMER_SOFTFIQ = 0, NR_SOFTIRQS };
-> extern void raise_softfiq(unsigned long nr);
-> extern void raise_softfiq_fiqoff(unsigned int nr);
-> extern void wakeup_softfiqd(void);
-> extern void open_softfiq(int nr, void (*action)(void));
-> #define __raise_softfiq_fiqoff(nr) do { or_softfiq_pending(1UL << (nr)); } while (0)
-> #define or_softfiq_pending(x)  (local_softfiq_pending() |= (x))
-> struct softfiq_action {...};
-> extern void do_softfiq(void);
-> extern void __do_softfiq(void);
-> #define set_softfiq_pending(x) (local_softfiq_pending() = (x))

\optee_os\core\arch\arm\kernel\generic_boot.c
-> #include <rtos_timer.h>
-> init_timers();

\optee_os\core\arch\arm\plat-vexpress\main.c
-> #include <rtos_hardfiq.h>
-> fiq_enter();
-> fiq_exit();

++++++++++++++++++++++++++++++++++++++++++++++++
optee process
++++++++++++++++++++++++++++++++++++++++++++++++
######phase 1######
\hello_world\ta\hello_world_ta.c
-> TA_OpenSessionEntryPoint(){...}

\optee_os\
+ process.ta ( \hello_world\ta\*.ta )

\optee_os\out\arm\core\
- tee.bin

\optee_os\scripts\gen_hashed_bin.py
-> ta_size = os.path.getsize("./process.ta");
-> init_size = pager_input_size + min(init_bin_size, paged_input_size) + hash_size + ta_size
-> append_to(outf, 0, './process.ta') (args.out)
-> append_to(outf, 0, './process.ta') (args.out_pager_v2)

\arm-trusted-firmware\services\spd\opteed\opteed_main.c
-> memcpy((void*)0x6100000ul, (void*)(0x6000000ul+init_size-0x226c4), 0x226c4u); (opteed_setup(void))

\optee_os\core\kernel\tee_ta_manager.c
-> static TEE_Result sn_tee_ta_init_session(...){...}
-> TEE_Result sn_tee_ta_open_session(...){...}

\optee_os\core\include\kernel\tee_ta_manager.h
-> TEE_Result sn_tee_ta_open_session(...);

\optee_os\core\arch\arm\tee\entry_std.c
-> static void sn_entry_open_session(struct thread_smc_args *smc_args){...}
-> void sn_tee_entry_std(struct thread_smc_args *smc_args){...}

\optee_os\core\arch\arm\include\tee\entry_std.h
-> void sn_tee_entry_std(struct thread_smc_args *args);

\optee_os\core\arch\arm\kernel\thread.c
-> #include <tee\entry_std.h>
-> void sn_thread_std_smc_entry(void);
-> static void sn_thread_alloc_and_run(void){...}
-> void __sn_thread_std_smc_entry(struct thread_smc_args *args __attribute__((unused))){...}
-> sn_thread_alloc_and_run();

\optee_os\core\arch\arm\kernel\thread_private.h
-> void __sn_thread_std_smc_entry(struct thread_smc_args *args);

\optee_os\core\arch\arm\kernel\thread_a64.S
-> FUNC sn_thread_std_smc_entry {... bl	__sn_thread_std_smc_entry ...} END_FUNC sn_thread_std_smc_entry

\optee_os\core\arch\arm\include\kernel\user_ta.h
-> TEE_Result sn_tee_ta_init_user_ta_session(const TEE_UUID *uuid, struct tee_ta_session *s);
-> TEE_Result sn_tee_ta_register_ta_store(const struct user_ta_store_ops *ops);

\optee_os\core\arch\arm\kernel\user_ta.c
-> static const struct user_ta_store_ops *sn_user_ta_store;
-> TEE_Result sn_tee_ta_register_ta_store(const struct user_ta_store_ops *ops){...}
-> TEE_Result sn_tee_ta_init_user_ta_session(const TEE_UUID *uuid, struct tee_ta_session *s){...}
-> static TEE_Result sn_ta_load(...){...}

\optee_os\core\arch\arm\kernel\ree_fs_ta.c
-> static TEE_Result sn_register_supplicant_user_ta(void){...}
-> service_init(sn_register_supplicant_user_ta);
-> static const struct user_ta_store_ops sn_ops = {.open = sn_ta_open, .close = sn_ta_close};
-> static void sn_ta_close(struct user_ta_store_handle *h){...}
-> static TEE_Result sn_ta_open(const TEE_UUID *uuid, struct user_ta_store_handle **h){...}

\optee_os\core\arch\arm\plat-vexpress\platform_config.h
-> #define CFG_TEE_RAM_VA_SIZE (2 * 1024 * 1024)

######phase 2######
\optee_os\scripts\gen_hashed_bin.py
-> process1_size	   = os.path.getsize("./process1.ta");
-> process2_size	   = os.path.getsize("./process2.ta");
-> init_size = pager_input_size + min(init_bin_size, paged_input_size) + hash_size + process1_size + process2_size
-> append_to(outf, 0, './process1.ta') (args.out)
-> append_to(outf, 0, './process2.ta')
-> append_to(outf, 0, './process1.ta') (args.out_pager_v2)
-> append_to(outf, 0, './process2.ta')

\arm-trusted-firmware\services\spd\opteed\opteed_main.c
-> memcpy((void*)0x6100000ul, (void*)(0x6000000ul + init_size - 0x44d88), 0x44d88u);

\optee_os\lib\libutee\arch\arm\user_ta_entry.c
-> unsigned num = 0;
-> while(1) {...res = entry_open_session(session_id, up); utee_sn_test();...}

\optee_os\lib\libutee\include\utee_syscalls.h
-> void utee_sn_test(void) __noreturn;

\optee_os\lib\libutee\arch\arm\utee_syscalls_asm.S
-> UTEE_SYSCALL utee_sn_test, TEE_SCN_SN_TEST, 0

\optee_os\lib\libutee\include\tee_syscall_numbers.h
-> #define TEE_SCN_SN_TEST 71
-> #define TEE_SCN_MAX 71

\optee_os\core\arch\arm\tee\arch_svc.c
-> SYSCALL_ENTRY(syscall_sn_test),

\optee_os\core\include\tee\tee_svc.h
-> void syscall_sn_test(void);

\optee_os\core\tee\tee_svc.c
-> void sn_thread_sched(void);
-> void syscall_sn_test(void){...}

\optee_os\core\arch\arm\kernel\thread_private.h
-> void sn_thread_sched(void);
-> void sn_thread_state_suspend(vaddr_t pc, uint32_t cpsr);

\optee_os\core\arch\arm\kernel\thread_a64.S
-> FUNC sn_thread_sched ... END_FUNC sn_thread_sched

\optee_os\core\arch\arm\kernel\thread.c
-> int sn_ta_num = 0;
-> void sn_thread_state_suspend(vaddr_t pc, uint32_t cpsr){...}

\optee_os\core\arch\arm\kernel\ree_fs_ta.c
-> if(sn_ta_num > 0){ta = (void*)0x61226c4ul;}
-> extern int sn_ta_num;

\hello_world\ta\hello_world_ta.c
-> DMSG("Hello World         A\n");

\optee_os\
+ process1.ta ( \hello_world\ta\*.ta )
+ process2.ta ( \hello_world\ta\*.ta )

\optee_os\out\arm\core\
- tee.bin

++++++++++++++++++++++++++++++++++++++++++++++++
optee sleep
++++++++++++++++++++++++++++++++++++++++++++++++
\optee_os\lib\libutee\arch\arm\user_ta_entry.c
-> utee_sleep();

\optee_os\lib\libutee\include\utee_syscalls.h
-> void utee_sleep(void) __noreturn;

\optee_os\lib\libutee\arch\arm\utee_syscalls_asm.S
-> UTEE_SYSCALL utee_sleep, TEE_SCN_SLEEP, 0

\optee_os\core\arch\arm\tee\arch_svc.c
-> SYSCALL_ENTRY(syscall_sleep),

\optee_os\core\include\tee\tee_svc.h
-> void syscall_sleep(void);

\optee_os\core\tee\tee_svc.c
-> #include <rtos_timer.h>
-> #include <rtos_wait.h>
-> void syscall_sleep(void){...}

\optee_os\core\kernel\
+ rtos_sched.c

\optee_os\core\kernel\sub.mk
-> srcs-y += rtos_sched.c

\optee_os\core\include\
+ rtos_wait.h

\optee_os\lib\libutee\include\tee_syscall_numbers.h
-> #define TEE_SCN_SLEEP 72
-> #define TEE_SCN_MAX 72

++++++++++++++++++++++++++++++++++++++++++++++++
optee schedule
++++++++++++++++++++++++++++++++++++++++++++++++
######phase 1######
\optee_os\core\arch\arm\plat-vexpress\main.c
-> void sn_sched(void);
-> sn_sched();

\optee_os\core\arch\arm\kernel\thread.c
-> void sn_sched(void);
-> void sn_sched(void){...}
-> struct thread_ctx th_head = { ... };

\optee_os\core\arch\arm\kernel\thread_a64.S
-> native_new_func ... native_old_func (.macro native_intr_handler mode:req)
-> foreign_new_func ... old_func (.macro foreign_intr_handler mode:req)

\optee_os\core\arch\arm\kernel\thread_private.h
-> struct thread_ctx* prev; (struct thread_ctx)
-> struct thread_ctx* next;

\optee_os\core\arch\arm\kernel\asm-defines.c
-> DEFINE(THREAD_CTX_REGS_CPSR, offsetof(struct thread_ctx_regs, cpsr));

\optee_os\lib\libutee\arch\arm\user_ta_entry.c
-> ...

\hello_world\ta\hello_world_ta.c
-> ...

######phase 2######
\optee_os\core\arch\arm\kernel\thread_a64.S
-> .macro intr_restore_process_context {...} .endm
-> .macro intr_save_process_context {...} .endm
-> .macro new_native_intr_handler mode:req {...} .endm
-> .macro native_intr_handler mode:req {...} .endm
-> process_native_intr_handler	fiq
-> process_native_intr_handler	irq

\optee_os\core\arch\arm\kernel\thread.c
-> #include <rtos_sched.h>
-> static void alloc_ready_process(void);
-> static void alloc_ready_process(void) {...}
-> void process_sched(void) {...}

\optee_os\core\kernel\rtos_timer.c
-> #include <rtos_sched.h>
-> scheduler_tick();

\optee_os\core\kernel\rtos_sched.c
-> #include <rtos_sched.h>
-> void scheduler_tick(void) {...}

\optee_os\core\include\
+ rtos_sched.h
