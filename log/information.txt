FVP
++++++++++++++++++++++++++++++++++++++++++++++++
ATF
++++++++++++++++++++++++++++++++++++++++++++++++
@system counter

#define SYS_COUNTER_FREQ_IN_TICKS	((1000 * 1000 * 1000) / 16)

$set frequency with ((1000 * 1000 * 1000) / 16)
/* 
 * CNTFRQ_EL0, Counter-timer Frequency register 
 * only be written in EL3
 * Indicates the system counter clock frequency, in Hz.
 */
-> CNTFRQ_EL0 ((1000 * 1000 * 1000) / 16)
------------------------------------------------
bl31_main
-bl31_arch_setup
--write_cntfrq_el0
------------------------------------------------

@GIC V2

[Secure]
GICD_IGROUPRn
[Common]
GICD_TYPER | GICD_SGIR 				
[Banked]
GICD_CTLR | GICC_CTLR | GICC_BPR

/* Base FVP compatible GIC memory map */
#define BASE_GICD_BASE			0x2f000000
#define BASE_GICR_BASE			0x2f100000
#define BASE_GICC_BASE			0x2c000000

#define ARM_IRQ_SEC_PHY_TIMER		29

#define ARM_IRQ_SEC_SGI_0		8
#define ARM_IRQ_SEC_SGI_1		9
#define ARM_IRQ_SEC_SGI_2		10
#define ARM_IRQ_SEC_SGI_3		11
#define ARM_IRQ_SEC_SGI_4		12
#define ARM_IRQ_SEC_SGI_5		13
#define ARM_IRQ_SEC_SGI_6		14
#define ARM_IRQ_SEC_SGI_7		15

#define FVP_IRQ_TZ_WDOG			56
#define FVP_IRQ_SEC_SYS_TIMER		57

$initialize the ARM GIC driver
/* In general, initialization just set some global variables. */
-> g_gicc_base = 0x2c000000 
-> g_gicd_base = 0x2f000000 
/* for v2, don't need to set g_gicr_base */
-> g_irq_sec_ptr = { {8,14}, {29,9,10,11,12,13,15,56,57} } 
------------------------------------------------
bl31_main
-bl31_platform_setup
--arm_bl31_platform_setup
---plat_arm_gic_driver_init
----arm_gic_init
------------------------------------------------

$setup the ARM GIC CPU interfaces
/* for v3, need to run gicv3_cpuif_setup() */
/* priority mask, 0~254(all) interrupts can be signals to the processor */
write GICC_PMR with 0xff 
-> GICC_PMR 0xff 
/* 
 * with GIC Security Extensions:
 * Group 0 interrupts are Secure interrupts
 * Group 1 interrupts are Non-secure interrupts
 *
 * Enable secure interrupts and use FIQs to route them. Disable legacy bypass.
 * ENABLE_GRP0 | FIQ_EN | 
 * FIQ_BYP_DIS_GRP0 | IRQ_BYP_DIS_GRP0 | FIQ_BYP_DIS_GRP1 | IRQ_BYP_DIS_GRP1
 */
write GICC_CTLR with 0b000111101001 (0x1e9) 
-> GICC_CTLR 0x1e9
------------------------------------------------
arm_bl31_platform_setup
-plat_arm_gic_init
--arm_gic_setup
---arm_gic_cpuif_setup
------------------------------------------------

#define GIC400_NUM_SPIS		480
#define MAX_PPIS		14
#define MAX_SGIS		16

#define MIN_SGI_ID		0
#define MIN_PPI_ID		16
#define MIN_SPI_ID		32

#define GIC_HIGHEST_SEC_PRIORITY 0
#define GIC_LOWEST_SEC_PRIORITY	127
#define GIC_HIGHEST_NS_PRIORITY	128
#define GIC_LOWEST_NS_PRIORITY	254 /* 255 would disable an interrupt */

$setup the ARM GIC distributor
/* Disable the distributor */
save the value of GICD_CTLR, clear ENABLE_GRP0 and ENABLE_GRP1 of GICD_CTLR
-> GICD_CTLR & 0xfffffffc
indicates the maximum number of interrup ts that the GIC supports, 1020(0~1019) ????
-> (GICD_TYPER.ITLinesNumber + 1) * 32
/* Mark out non-secure SPI interrupts */
allocate all SPIs to Group 1
-> GICD_IGROUPR<1-31> 0xffffffff
set the priority of SPI interrupts with 0x80 (128)
-> GICD_IPRIORITYR<1-254> 0x80808080 ????
get the current CPU bit mask from GICD_ITARGETSR0 ????
-> GICD_ITARGETSR0 & 0xff
/* Configure SPI secure interrupts now */
-> SPI 56 57
-> allocate the SPI to Group 0
-> set the priority of the SPI with 0 ????
-> set GICD_ITARGETSR of the SPI with GICD_ITARGETSR0 & 0xff
-> enable the SPI interrupt by setting the bit of GICD_ISENABLER with 1

/*
 * Configure the SGI and PPI. This is done in a separated function
 * because each CPU is responsible for initializing its own private
 * interrupts.
 * Per cpu gic distributor setup which will be done by all cpus after a cold
 * boot/hotplug. This marks out the secure interrupts & enables them.
 */

--arm_gic_pcpu_distif_setup ****
setup SGI and PPI priorities
-> GICD_IPRIORITYR<0> 0x80808080
-> SGI/PPI 8,14,29,9,10,11,12,13,15
-> set the priority of the SGI/PPI with 0 ????
-> enable the SGI/PPI interrupt by setting the bit of GICD_ISENABLER with 1

-> allocate these SGI/PPI to Group 0, other SGI/PPI to Group 1 by writting GICD_IGROUPR<0>
------------------------------------------------
/* enable the distributor, add forwarding interrupts of Group 0 */
restore the value of GICD_CTLR, set ENABLE_GRP0 with 1
-> GICD_CTLR | ENABLE_GRP0
------------------------------------------------
arm_gic_setup
-arm_gic_distif_setup
------------------------------------------------
@The memory-mapped counter module

/* Memory mapped Generic timer interfaces  */
#define ARM_SYS_CNTCTL_BASE		0x2a430000
#define ARM_SYS_CNTREAD_BASE	0x2a800000
#define ARM_SYS_TIMCTL_BASE		0x2a810000

/* Generic timer memory mapped registers & offsets */
#define CNTCR_OFF			0x000
#define CNTFID_OFF			0x020

#define CNTCR_EN			(1 << 0)
#define CNTCR_HDBG			(1 << 1)
#define CNTCR_FCREQ(x)		((x) << 8)

/* 
 * CNTCR, Counter Control Register
 * only writable by Secure accesses.
 * When this register has an architecturally-defined reset value, 
 * FCREQ reset to 0
 */
set CNTCR.En with 1 to enable system counter, CNTCR.FCREQ reset to 0
-> CNTCR 0x1
------------------------------------------------
bl31_main
-bl31_platform_setup
--arm_bl31_platform_setup
------------------------------------------------
@The memory-mapped timer control module
/*
 * Definitions of register offsets and fields in the CNTCTLBase Frame of the
 * system level implementation of the Generic Timer.
 */
#define CNTNSAR			0x4
#define CNTNSAR_NS_SHIFT(x)	x

#define CNTACR_BASE(x)		(0x40 + (x << 2))
#define CNTACR_RPCT_SHIFT	0x0
#define CNTACR_RVCT_SHIFT	0x1
#define CNTACR_RFRQ_SHIFT	0x2
#define CNTACR_RVOFF_SHIFT	0x3
#define CNTACR_RWVT_SHIFT	0x4
#define CNTACR_RWPT_SHIFT	0x5

/* System timer related constants */
#define PLAT_ARM_NSTIMER_FRAME_ID		1

/* 
 * CNTACR<n>, Counter-timer Access Control Registers, n = 0 - 7 
 * CNTACR<n> provides the controls for frame CNTBaseN
 */
 CNTBase1 memory map:
 read-only - CNTPCT
 read-only - CNTVCT
 read-only - CNTFRQ
 read-only - CNTVOFF
 read/write - EL1 physical registers (CNTP_CVAL CNTP_TVAL CNTP_CTL)
 read/write - virtual timer registers (CNTV_CVAL CNTV_TVAL CNTV_CTL)
 -> CNTACR<1> 0x3f (0b111111)
/* 
 * CNTNSAR, Counter-timer Non-secure Access Register
 * CNTACR<n> is always accessible by Secure accesses.
 * CNTNSAR.NS<n> determines whether CNTACR<n> is accessible by Non-secure accesses
 */
 -> CNTNSAR 0x2 (0b10)
------------------------------------------------
arm_bl31_platform_setup
-arm_configure_sys_timer
------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++
TSP
++++++++++++++++++++++++++++++++++++++++++++++++
@GIC V2
-> the same as ATF
------------------------------------------------
tsp_main
-tsp_platform_setup
--plat_arm_gic_driver_init
--plat_arm_gic_init
------------------------------------------------

@Generic Timer
/* initializes the generic timer to fire every 0.5 second */
/* no memory-mapped*/
/* The CNTPCT_EL0 register holds the current physical counter value */
/*
 * TimerConditionMet = (((Counter[63:0] – Offset[63:0])[63:0] - CompareValue[63:0]) >= 0)
 * Reads TimerValue = (CompareValue – (Counter - Offset))[31:0] 
 * Writes CompareValue = ((Counter - Offset)[63:0] + SignExtend(TimerValue))[63:0]
 */
write CNTPS_CVAL_EL1
-> CNTPS_CVAL_EL1 = CNTPCT_EL0 + CNTFRQ_EL0 / 2
/* Enable the secure physical timer, EL3 physical timer */
/* Timer interrupt is not masked */
write CNTPS_CTL_EL1
-> CNTPS_CTL_EL1 0x1 
------------------------------------------------
tsp_main
-tsp_generic_timer_start
------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++
OPTEE
++++++++++++++++++++++++++++++++++++++++++++++++
@GIC v2

#define GIC_BASE		0x2c000000
#define GICC_OFFSET		0x0
#define GICD_OFFSET		0x3000000

register physical memory (MEM_AREA_IO_SEC)
transition physical address to virtual address
-> gicc_base(virt)
-> gicd_base(virt)
------------------------------------------------
generic_boot_init_primary
-init_primary_helper
--main_init_gic
------------------------------------------------

/* On ARMv8, GIC configuration is initialized in ARM-TF */
initialize gic driver, set global variable gic_data
-> gic_data

struct gic_data {
	vaddr_t gicc_base;
	vaddr_t gicd_base;
	size_t max_it;
	struct itr_chip chip;
};

static const struct itr_ops gic_ops = {
	.add = gic_op_add,
	.enable = gic_op_enable,
	.disable = gic_op_disable,
	.raise_pi = gic_op_raise_pi,
	.raise_sgi = gic_op_raise_sgi,
	.set_affinity = gic_op_set_affinity,
};
------------------------------------------------
main_init_gic
-gic_init_base_addr
------------------------------------------------
save GICC_CTLR, clear GICC_CTLR with 0
-> GICC_CTLR 0x0
probe which interrupt number is the largest ????
-> get max_it
restore GICC_CTLR
-> GICC_CTLR 0x1e9
------------------------------------------------
gic_init_base_addr
-probe_max_it
------------------------------------------------

set global variable itr_chip
-> itr_chip
------------------------------------------------
main_init_gic
-itr_init
------------------------------------------------

set the CPU mask to deliver interrupts to any online core
-> GICD_ITARGETSR 0xff
------------------------------------------------
gic_op_add
-gic_it_set_cpu_mask
------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++
OPTEE boot
++++++++++++++++++++++++++++++++++++++++++++++++
vbar_el1: reset_vect_table
sctlr_el1: SCTLR_I | SCTLR_A | SCTLR_SA
copy init code and rodata into correct location
------------------------------------------------
__data_end -> __text_init_start ~ __rodata_init_end
------------------------------------------------

SP_EL0: stack_tmp + (cpu_id + 1) * stack_tmp_stride - stack_tmp_offset
------------------------------------------------
uint32_t stack_tmp[8][512 + 8]

+----------+
|canary	   | 4 * 4
+----------+ <- SP_EL0
|          |
|          | 512 * 4
|          |
+----------+
|canary    | 4 * 4
+----------+

------------------------------------------------

SP_EL1: &thread_core_local[cpu_id]
------------------------------------------------
struct thread_core_local thread_core_local[8]
------------------------------------------------

set sp with SP_EL0
enable SError interrupt
invalidate dcache
------------------------------------------------
__text_start ~ __end
------------------------------------------------

enable console
init mmu_map
------------------------------------------------
+--------+---------+
| TZDRAM | TA_RAM  |
|        +---------+
|        | SDP RAM | (SDP test pool, optional)
+--------+---------+

nsec_shared
[
	SHMEM: 0x8300 0000 (pa) | 0x20 0000 
]

secure_only
[
	TZDRAM: 0x0600 0000 (pa) | 0x0200 0000
]

static_memory_map
{
	map_tee_map
	{
		Name: TEE_RAM
		Pa: 0x0600 0000 ( 96M )
		Size: 1M
		Type: MEM_AREA_TEE_RAM
	}

	map_ta_map
	{
		Name: TA_RAM
		Pa: 0x0620 0000 ( 98M )
		Size: 30M
		Type: MEM_AREA_TA_RAM
	}

	map_nsec_shm
	{
		Name: SHRED_MEM
		Pa: 0x8300 0000 ( 2096M )
		Size: 2M
		Type: MEM_AREA_NSEC_SHM
	}

	{
		Name: CONSOLE_UART
		Pa: 0x1c00 0000 ( 448M)
		Size: 2M
		Type: MEM_AREA_IO_SEC
	}

	{
		Name: GICD
		Pa: 0x2c00 0000 ( 704M )
		Size： 2M
		Type: MEM_AREA_IO_SEC
	}

	{
		Name: GICC
		Pa: 0x2f00 0000 ( 752M )
		Size: 2M
		Type: MEM_AREA_IO_SEC
	}

	{
		Name: RES_MEM
		Pa:  0x0000 0000
		Size: 20M
		Type: MEM_AREA_RES_VASPACE
	}
}

------------------------------------------------

init mmu_tables
------------------------------------------------
| L1 | L2 | L3 | page |
| 2  | 9  | 9  | 12   |

//Main MMU L1 table for teecore
uint32_t main_mmu_l1_ttb[4096]


------------------------------------------------

init mmu_regs
------------------------------------------------
//Memory Attribute Indirection Register (EL1)
write mair_el1 0xff04
//Translation Control Register (EL1)
write tcr_el1 (set 31 23 13 12 11 10 9 8 5 bit to 1) | tcr_ps_bits <<32
/*
TCR_EL1 has two TxSZ fields, corresponding to the two VA subranges:
— TCR_EL1.T0SZ specifies the size for the lower VA range, translated using TTBR0_EL1.
— TCR_EL1.T1SZ specifies the size for the upper VA range, translated using TTBR1_EL1
*/
write ttbr0_el1 V2P(l1_xlation_table[cpu_id])
write ttbr1_el1 0
------------------------------------------------

enable mmu
------------------------------------------------
invalidate TLB
//EL1 and EL0 stage 1 address translation enabled
set sctlr_el1.M to 1
------------------------------------------------

enable icache
------------------------------------------------
set sctlr_el1.I to 1
------------------------------------------------

enable dcache
------------------------------------------------
set sctlr_el1.C to 1
------------------------------------------------

mask (A I F) exceptions
------------------------------------------------
A SError
I IRQ
F FIQ
set daif.A|I|F to 1
------------------------------------------------

disable vfp
------------------------------------------------
//CPACR_EL1, Architectural Feature Access Control Register
set cpacr_el1.FPEN to 0x00
/* 
 * Causes any instructions in EL0 or EL1 that use the registers associated with
 * floating-point and Advanced SIMD execution to be trapped
 */
------------------------------------------------

zero BSS area ( __bss_start ~ __bss_end )
init boot thread
------------------------------------------------
link all threads.mutexes | tsd.sess_stack | tsd.pgt_cache
set all cpus ' thread_core_local.curr_thread with -1 except local cpu
set thread_core_local[l].curr_thread with 0
set threads[0].state with THREAD_STATE_ACTIVE
------------------------------------------------

init asan ( address sanitizing )
add pool ( __heap1_start ~ __heap1_end )
init ta_ram
init handlers
------------------------------------------------
std_smc
fast_smc
nintr
cpu_on
cpu_off
cpu_suspend
cpu_resume
system_off
system_reset
------------------------------------------------

init canary
------------------------------------------------
stack_tmp 
stack_abt 
stack_thread
+----------+
|0xabababab| 1 * 4 
+----------+
|          | 3 * 4
+----------+ 
|          |
|          | 
|          |
+----------+
|          | 3 * 4
+----------+
|0xdededede| 1 * 4 
+----------+
------------------------------------------------

init thread stacks
------------------------------------------------
stack_thread[2][2048 + 8]

+----------+
|canary	   | 4 * 4
+----------+ <- threads[thread_id].stack_va_end
|          |
|          | 2048 * 4
|          |
+----------+
|canary    | 4 * 4
+----------+
------------------------------------------------

init pgt
------------------------------------------------
------------------------------------------------

set tmp_stack
------------------------------------------------
stack_tmp[pos]
+----------+
|canary	   | 4 * 4
+----------+ <- thread_core_local[pos].tmp_stack_va_end
|          |
|          | 512 * 4
|          |
+----------+
|canary    | 4 * 4
+----------+
------------------------------------------------

set abt_stack
------------------------------------------------
stack_abt[pos]
+----------+
|canary	   | 4 * 4
+----------+ <- thread_core_local[pos].tmp_stack_va_end
|          |
|          | 256 * 4
|          |
+----------+
|canary    | 4 * 4
+----------+
------------------------------------------------

init vbar
------------------------------------------------
vbar_el1: thread_vect_table
------------------------------------------------
init fdt
------------------------------------------------
------------------------------------------------
configure console from dt
------------------------------------------------
------------------------------------------------

init gic
------------------------------------------------
mentioned above
------------------------------------------------

init support for future mapping of TAs
------------------------------------------------
------------------------------------------------

init time source
------------------------------------------------
set _time_source
------------------------------------------------

call init_calls
------------------------------------------------
(*call)() in __initcall_start ~ __initcall_end
------------------------------------------------

flush dcache: __text_start ~ __end

clear boot thread
------------------------------------------------
threads[ thread_core_local[pos].curr_thread ].state = THREAD_STATE_FREE
thread_core_local[pos].curr_thread = -1
------------------------------------------------
smc #0

++++++++++++++++++++++++++++++++++++++++++++++++
OPTEE Interrupt
++++++++++++++++++++++++++++++++++++++++++++++++
[el0_fiq_a64] (\optee_os\core\arch\arm\kernel\thread_a64.S)

sp: ?
x[0]~x[3] -> thread_core_local.x[4](stack sp)
b elx_fiq

[elx_fiq] (native_intr_handler fiq) (\optee_os\core\arch\arm\kernel\thread_a64.S)

native_old_func:
thread_core_local.flags(stack sp) -> w1
w1 << 4(CLF_SAVED_SHIFT) -> w1
w1 | (1 << 3)(CLF_FIQ) -> w1
w1 | (1 << 0)(CLF_TMP) -> w1
w1 -> thread_core_local.flags(stack sp)

/* load tmp_stack_va_end */
thread_core_local.tmp_stack_va_end(stack sp) -> x1
sp_el0 -> x2

#0 -> spsel 
sp: sp_el0

x1 -> sp (sp_el0: tmp_stack_va_end)

/*
 * Save registers on stack that can be corrupted by a call to
 * a C function
 */

/* Make room for struct elx_nintr_rec */
/*
 * This struct is never used from C it's only here to visualize the
 * layout.
 *
 * struct elx_nintr_rec {
 * 	uint64_t x[19 - 4]; x4..x18
 * 	uint64_t lr;
 * 	uint64_t sp_el0;
 * };
 */

sp - #ELX_NINTR_REC_SIZE -> sp

/* Store x4..x18 */
x[4]~x[18] -> elx_nintr_rec.x[15] (stack sp)

/* Store lr and original sp_el0 */
x30 -> elx_nintr_rec.lr (stack sp)
x2 -> elx_nintr_rec.sp_el0 (stack sp)

bl	thread_check_canaries (stack_tmp)
blr main_fiq (xl6 used)

/*
 * Restore registers
 */
 /* Restore x4..x18 */
elx_nintr_rec.x[15] (stack sp) -> x[4]~x[18] 

/* Load  lr and original sp_el0 */
elx_nintr_rec.lr (stack sp) -> x30
elx_nintr_rec.sp_el0 (stack sp) -> x2

/* Restore SP_El0 */
x2 -> sp(sp_el0)

/* Switch back to SP_EL1 */
#1 -> spsel
sp: sp_el1

/* Update core local flags */
thread_core_local.flags(stack sp) -> w0
w0 >> 4(CLF_SAVED_SHIFT) -> w0
w0 -> thread_core_local.flags(stack sp)

/* Restore x0..x3 */
thread_core_local.x[4](stack sp) -> x[0]~x[3]

/* Return from exception */
eret












