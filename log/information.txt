FVP
++++++++++++++++++++++++++++++++++++++++++++++++
ATF
++++++++++++++++++++++++++++++++++++++++++++++++
@system counter

#define SYS_COUNTER_FREQ_IN_TICKS	((1000 * 1000 * 1000) / 16)

$set frequency with ((1000 * 1000 * 1000) / 16)
/* 
 * CNTFRQ_EL0, Counter-timer Frequency register 
 * only be written in EL3
 * Indicates the system counter clock frequency, in Hz.
 */
-> CNTFRQ_EL0 ((1000 * 1000 * 1000) / 16)
------------------------------------------------
bl31_main
-bl31_arch_setup
--write_cntfrq_el0
------------------------------------------------

@GIC V2

[Secure]
GICD_IGROUPRn
[Common]
GICD_TYPER | GICD_SGIR 				
[Banked]
GICD_CTLR | GICC_CTLR | GICC_BPR

/* Base FVP compatible GIC memory map */
#define BASE_GICD_BASE			0x2f000000
#define BASE_GICR_BASE			0x2f100000
#define BASE_GICC_BASE			0x2c000000

#define ARM_IRQ_SEC_PHY_TIMER		29

#define ARM_IRQ_SEC_SGI_0		8
#define ARM_IRQ_SEC_SGI_1		9
#define ARM_IRQ_SEC_SGI_2		10
#define ARM_IRQ_SEC_SGI_3		11
#define ARM_IRQ_SEC_SGI_4		12
#define ARM_IRQ_SEC_SGI_5		13
#define ARM_IRQ_SEC_SGI_6		14
#define ARM_IRQ_SEC_SGI_7		15

#define FVP_IRQ_TZ_WDOG			56
#define FVP_IRQ_SEC_SYS_TIMER		57

$initialize the ARM GIC driver
/* In general, initialization just set some global variables. */
-> g_gicc_base = 0x2c000000 
-> g_gicd_base = 0x2f000000 
/* for v2, don't need to set g_gicr_base */
-> g_irq_sec_ptr = { {8,14}, {29,9,10,11,12,13,15,56,57} } 
------------------------------------------------
bl31_main
-bl31_platform_setup
--arm_bl31_platform_setup
---plat_arm_gic_driver_init
----arm_gic_init
------------------------------------------------

$setup the ARM GIC CPU interfaces
/* for v3, need to run gicv3_cpuif_setup() */
/* priority mask, 0~254(all) interrupts can be signals to the processor */
write GICC_PMR with 0xff 
-> GICC_PMR 0xff 
/* 
 * with GIC Security Extensions:
 * Group 0 interrupts are Secure interrupts
 * Group 1 interrupts are Non-secure interrupts
 *
 * Enable secure interrupts and use FIQs to route them. Disable legacy bypass.
 * ENABLE_GRP0 | FIQ_EN | 
 * FIQ_BYP_DIS_GRP0 | IRQ_BYP_DIS_GRP0 | FIQ_BYP_DIS_GRP1 | IRQ_BYP_DIS_GRP1
 */
write GICC_CTLR with 0b000111101001 (0x1e9) 
-> GICC_CTLR 0x1e9
------------------------------------------------
arm_bl31_platform_setup
-plat_arm_gic_init
--arm_gic_setup
---arm_gic_cpuif_setup
------------------------------------------------

#define GIC400_NUM_SPIS		480
#define MAX_PPIS		14
#define MAX_SGIS		16

#define MIN_SGI_ID		0
#define MIN_PPI_ID		16
#define MIN_SPI_ID		32

#define GIC_HIGHEST_SEC_PRIORITY 0
#define GIC_LOWEST_SEC_PRIORITY	127
#define GIC_HIGHEST_NS_PRIORITY	128
#define GIC_LOWEST_NS_PRIORITY	254 /* 255 would disable an interrupt */

$setup the ARM GIC distributor
/* Disable the distributor */
save the value of GICD_CTLR, clear ENABLE_GRP0 and ENABLE_GRP1 of GICD_CTLR
-> GICD_CTLR & 0xfffffffc
indicates the maximum number of interrup ts that the GIC supports, 1020(0~1019) ????
-> (GICD_TYPER.ITLinesNumber + 1) * 32
/* Mark out non-secure SPI interrupts */
allocate all SPIs to Group 1
-> GICD_IGROUPR<1-31> 0xffffffff
set the priority of SPI interrupts with 0x80 (128)
-> GICD_IPRIORITYR<1-254> 0x80808080 ????
get the current CPU bit mask from GICD_ITARGETSR0 ????
-> GICD_ITARGETSR0 & 0xff
/* Configure SPI secure interrupts now */
-> SPI 56 57
-> allocate the SPI to Group 0
-> set the priority of the SPI with 0 ????
-> set GICD_ITARGETSR of the SPI with GICD_ITARGETSR0 & 0xff
-> enable the SPI interrupt by setting the bit of GICD_ISENABLER with 1

/*
 * Configure the SGI and PPI. This is done in a separated function
 * because each CPU is responsible for initializing its own private
 * interrupts.
 * Per cpu gic distributor setup which will be done by all cpus after a cold
 * boot/hotplug. This marks out the secure interrupts & enables them.
 */

--arm_gic_pcpu_distif_setup ****
setup SGI and PPI priorities
-> GICD_IPRIORITYR<0> 0x80808080
-> SGI/PPI 8,14,29,9,10,11,12,13,15
-> set the priority of the SGI/PPI with 0 ????
-> enable the SGI/PPI interrupt by setting the bit of GICD_ISENABLER with 1

-> allocate these SGI/PPI to Group 0, other SGI/PPI to Group 1 by writting GICD_IGROUPR<0>
------------------------------------------------
/* enable the distributor, add forwarding interrupts of Group 0 */
restore the value of GICD_CTLR, set ENABLE_GRP0 with 1
-> GICD_CTLR | ENABLE_GRP0
------------------------------------------------
arm_gic_setup
-arm_gic_distif_setup
------------------------------------------------
@The memory-mapped counter module

/* Memory mapped Generic timer interfaces  */
#define ARM_SYS_CNTCTL_BASE		0x2a430000
#define ARM_SYS_CNTREAD_BASE	0x2a800000
#define ARM_SYS_TIMCTL_BASE		0x2a810000

/* Generic timer memory mapped registers & offsets */
#define CNTCR_OFF			0x000
#define CNTFID_OFF			0x020

#define CNTCR_EN			(1 << 0)
#define CNTCR_HDBG			(1 << 1)
#define CNTCR_FCREQ(x)		((x) << 8)

/* 
 * CNTCR, Counter Control Register
 * only writable by Secure accesses.
 * When this register has an architecturally-defined reset value, 
 * FCREQ reset to 0
 */
set CNTCR.En with 1 to enable system counter, CNTCR.FCREQ reset to 0
-> CNTCR 0x1
------------------------------------------------
bl31_main
-bl31_platform_setup
--arm_bl31_platform_setup
------------------------------------------------
@The memory-mapped timer control module
/*
 * Definitions of register offsets and fields in the CNTCTLBase Frame of the
 * system level implementation of the Generic Timer.
 */
#define CNTNSAR			0x4
#define CNTNSAR_NS_SHIFT(x)	x

#define CNTACR_BASE(x)		(0x40 + (x << 2))
#define CNTACR_RPCT_SHIFT	0x0
#define CNTACR_RVCT_SHIFT	0x1
#define CNTACR_RFRQ_SHIFT	0x2
#define CNTACR_RVOFF_SHIFT	0x3
#define CNTACR_RWVT_SHIFT	0x4
#define CNTACR_RWPT_SHIFT	0x5

/* System timer related constants */
#define PLAT_ARM_NSTIMER_FRAME_ID		1

/* 
 * CNTACR<n>, Counter-timer Access Control Registers, n = 0 - 7 
 * CNTACR<n> provides the controls for frame CNTBaseN
 */
 CNTBase1 memory map:
 read-only - CNTPCT
 read-only - CNTVCT
 read-only - CNTFRQ
 read-only - CNTVOFF
 read/write - EL1 physical registers (CNTP_CVAL CNTP_TVAL CNTP_CTL)
 read/write - virtual timer registers (CNTV_CVAL CNTV_TVAL CNTV_CTL)
 -> CNTACR<1> 0x3f (0b111111)
/* 
 * CNTNSAR, Counter-timer Non-secure Access Register
 * CNTACR<n> is always accessible by Secure accesses.
 * CNTNSAR.NS<n> determines whether CNTACR<n> is accessible by Non-secure accesses
 */
 -> CNTNSAR 0x2 (0b10)
------------------------------------------------
arm_bl31_platform_setup
-arm_configure_sys_timer
------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++
TSP
++++++++++++++++++++++++++++++++++++++++++++++++
@GIC V2
-> the same as ATF
------------------------------------------------
tsp_main
-tsp_platform_setup
--plat_arm_gic_driver_init
--plat_arm_gic_init
------------------------------------------------

@Generic Timer
/* initializes the generic timer to fire every 0.5 second */
/* no memory-mapped*/
/* The CNTPCT_EL0 register holds the current physical counter value */
/*
 * TimerConditionMet = (((Counter[63:0] – Offset[63:0])[63:0] - CompareValue[63:0]) >= 0)
 * Reads TimerValue = (CompareValue – (Counter - Offset))[31:0] 
 * Writes CompareValue = ((Counter - Offset)[63:0] + SignExtend(TimerValue))[63:0]
 */
write CNTPS_CVAL_EL1
-> CNTPS_CVAL_EL1 = CNTPCT_EL0 + CNTFRQ_EL0 / 2
/* Enable the secure physical timer, EL3 physical timer */
/* Timer interrupt is not masked */
write CNTPS_CTL_EL1
-> CNTPS_CTL_EL1 0x1 
------------------------------------------------
tsp_main
-tsp_generic_timer_start
------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++
OPTEE
++++++++++++++++++++++++++++++++++++++++++++++++
@GIC v2

#define GIC_BASE		0x2c000000
#define GICC_OFFSET		0x0
#define GICD_OFFSET		0x3000000

register physical memory (MEM_AREA_IO_SEC)
transition physical address to virtual address
-> gicc_base(virt)
-> gicd_base(virt)
------------------------------------------------
generic_boot_init_primary
-init_primary_helper
--main_init_gic
------------------------------------------------

/* On ARMv8, GIC configuration is initialized in ARM-TF */
initialize gic driver, set global variable gic_data
-> gic_data

struct gic_data {
	vaddr_t gicc_base;
	vaddr_t gicd_base;
	size_t max_it;
	struct itr_chip chip;
};

static const struct itr_ops gic_ops = {
	.add = gic_op_add,
	.enable = gic_op_enable,
	.disable = gic_op_disable,
	.raise_pi = gic_op_raise_pi,
	.raise_sgi = gic_op_raise_sgi,
	.set_affinity = gic_op_set_affinity,
};
------------------------------------------------
main_init_gic
-gic_init_base_addr
------------------------------------------------
save GICC_CTLR, clear GICC_CTLR with 0
-> GICC_CTLR 0x0
probe which interrupt number is the largest ????
-> get max_it
restore GICC_CTLR
-> GICC_CTLR 0x1e9
------------------------------------------------
gic_init_base_addr
-probe_max_it
------------------------------------------------

set global variable itr_chip
-> itr_chip
------------------------------------------------
main_init_gic
-itr_init
------------------------------------------------

set the CPU mask to deliver interrupts to any online core
-> GICD_ITARGETSR 0xff
------------------------------------------------
gic_op_add
-gic_it_set_cpu_mask
------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++
OPTEE boot
++++++++++++++++++++++++++++++++++++++++++++++++
vbar_el1: reset_vect_table
sctlr_el1: SCTLR_I | SCTLR_A | SCTLR_SA
copy init code and rodata into correct location
------------------------------------------------
__data_end -> __text_init_start ~ __rodata_init_end
------------------------------------------------

SP_EL0: stack_tmp + (cpu_id + 1) * stack_tmp_stride - stack_tmp_offset
------------------------------------------------
uint32_t stack_tmp[8][512 + 8]

+----------+
|canary	   | 4 * 4
+----------+ <- SP_EL0
|          |
|          | 512 * 4
|          |
+----------+
|canary    | 4 * 4
+----------+

------------------------------------------------

SP_EL1: &thread_core_local[cpu_id]
------------------------------------------------
struct thread_core_local thread_core_local[8]
------------------------------------------------

set sp with SP_EL0
enable SError interrupt
invalidate dcache
------------------------------------------------
__text_start ~ __end
------------------------------------------------

enable console
init mmu_map
------------------------------------------------
+--------+---------+
| TZDRAM | TA_RAM  |
|        +---------+
|        | SDP RAM | (SDP test pool, optional)
+--------+---------+

nsec_shared
[
	SHMEM: 0x8300 0000 (pa) | 0x20 0000 
]

secure_only
[
	TZDRAM: 0x0600 0000 (pa) | 0x0200 0000
]

static_memory_map
{
	map_tee_map
	{
		Name: TEE_RAM
		Pa: 0x0600 0000 ( 96M )
		Size: 1M
		Type: MEM_AREA_TEE_RAM
	}

	map_ta_map
	{
		Name: TA_RAM
		Pa: 0x0620 0000 ( 98M )
		Size: 30M
		Type: MEM_AREA_TA_RAM
	}

	map_nsec_shm
	{
		Name: SHRED_MEM
		Pa: 0x8300 0000 ( 2096M )
		Size: 2M
		Type: MEM_AREA_NSEC_SHM
	}

	{
		Name: CONSOLE_UART
		Pa: 0x1c00 0000 ( 448M)
		Size: 2M
		Type: MEM_AREA_IO_SEC
	}

	{
		Name: GICD
		Pa: 0x2c00 0000 ( 704M )
		Size： 2M
		Type: MEM_AREA_IO_SEC
	}

	{
		Name: GICC
		Pa: 0x2f00 0000 ( 752M )
		Size: 2M
		Type: MEM_AREA_IO_SEC
	}

	{
		Name: RES_MEM
		Pa:  0x0000 0000
		Size: 20M
		Type: MEM_AREA_RES_VASPACE
	}
}

------------------------------------------------

init mmu_tables
------------------------------------------------
| L1 | L2 | L3 | page |
| 2  | 9  | 9  | 12   |

//Main MMU L1 table for teecore
uint32_t main_mmu_l1_ttb[4096]


------------------------------------------------

init mmu_regs
------------------------------------------------
//Memory Attribute Indirection Register (EL1)
write mair_el1 0xff04
//Translation Control Register (EL1)
write tcr_el1 (set 31 23 13 12 11 10 9 8 5 bit to 1) | tcr_ps_bits <<32
/*
TCR_EL1 has two TxSZ fields, corresponding to the two VA subranges:
— TCR_EL1.T0SZ specifies the size for the lower VA range, translated using TTBR0_EL1.
— TCR_EL1.T1SZ specifies the size for the upper VA range, translated using TTBR1_EL1
*/
write ttbr0_el1 V2P(l1_xlation_table[cpu_id])
write ttbr1_el1 0
------------------------------------------------

enable mmu
------------------------------------------------
invalidate TLB
//EL1 and EL0 stage 1 address translation enabled
set sctlr_el1.M to 1
------------------------------------------------

enable icache
------------------------------------------------
set sctlr_el1.I to 1
------------------------------------------------

enable dcache
------------------------------------------------
set sctlr_el1.C to 1
------------------------------------------------

mask (A I F) exceptions
------------------------------------------------
A SError
I IRQ
F FIQ
set daif.A|I|F to 1
------------------------------------------------

disable vfp
------------------------------------------------
//CPACR_EL1, Architectural Feature Access Control Register
set cpacr_el1.FPEN to 0x00
/* 
 * Causes any instructions in EL0 or EL1 that use the registers associated with
 * floating-point and Advanced SIMD execution to be trapped
 */
------------------------------------------------

zero BSS area ( __bss_start ~ __bss_end )
init boot thread
------------------------------------------------
link all threads.mutexes | tsd.sess_stack | tsd.pgt_cache
set all cpus ' thread_core_local.curr_thread with -1 except local cpu
set thread_core_local[l].curr_thread with 0
set threads[0].state with THREAD_STATE_ACTIVE
------------------------------------------------

init asan ( address sanitizing )
add pool ( __heap1_start ~ __heap1_end )
init ta_ram
init handlers
------------------------------------------------
std_smc
fast_smc
nintr
cpu_on
cpu_off
cpu_suspend
cpu_resume
system_off
system_reset
------------------------------------------------

init canary
------------------------------------------------
stack_tmp 
stack_abt 
stack_thread
+----------+
|0xabababab| 1 * 4 
+----------+
|          | 3 * 4
+----------+ 
|          |
|          | 
|          |
+----------+
|          | 3 * 4
+----------+
|0xdededede| 1 * 4 
+----------+
------------------------------------------------

init thread stacks
------------------------------------------------
stack_thread[2][2048 + 8]

+----------+
|canary	   | 4 * 4
+----------+ <- threads[thread_id].stack_va_end
|          |
|          | 2048 * 4
|          |
+----------+
|canary    | 4 * 4
+----------+
------------------------------------------------

init pgt
------------------------------------------------
------------------------------------------------

set tmp_stack
------------------------------------------------
stack_tmp[pos]
+----------+
|canary	   | 4 * 4
+----------+ <- thread_core_local[pos].tmp_stack_va_end
|          |
|          | 512 * 4
|          |
+----------+
|canary    | 4 * 4
+----------+
------------------------------------------------

set abt_stack
------------------------------------------------
stack_abt[pos]
+----------+
|canary	   | 4 * 4
+----------+ <- thread_core_local[pos].tmp_stack_va_end
|          |
|          | 256 * 4
|          |
+----------+
|canary    | 4 * 4
+----------+
------------------------------------------------

init vbar
------------------------------------------------
vbar_el1: thread_vect_table
------------------------------------------------
init fdt
------------------------------------------------
------------------------------------------------
configure console from dt
------------------------------------------------
------------------------------------------------

init gic
------------------------------------------------
mentioned above
------------------------------------------------

init support for future mapping of TAs
------------------------------------------------
------------------------------------------------

init time source
------------------------------------------------
set _time_source
------------------------------------------------

call init_calls
------------------------------------------------
(*call)() in __initcall_start ~ __initcall_end
------------------------------------------------

flush dcache: __text_start ~ __end

clear boot thread
------------------------------------------------
threads[ thread_core_local[pos].curr_thread ].state = THREAD_STATE_FREE
thread_core_local[pos].curr_thread = -1
------------------------------------------------
smc #0

++++++++++++++++++++++++++++++++++++++++++++++++
OPTEE Interrupt
++++++++++++++++++++++++++++++++++++++++++++++++
[el0_fiq_a64] (\optee_os\core\arch\arm\kernel\thread_a64.S)

sp: sp_el1
x[0]~x[3] -> thread_core_local.x[4](stack sp)
b elx_fiq
------------------------------------------------
[elx_fiq] (native_intr_handler fiq) (\optee_os\core\arch\arm\kernel\thread_a64.S)

native_new_func:
thread_core_local.curr_thread(stack sp) -> x0
if(x0 == -1) (no running thread)
{
	jmp native_old_func
}
else
{
	/* get_thread_ctx */
	thread_core_local.curr_thread(stack sp) -> w1
	&threads[0] -> x0
	sizeof(struct thread_ctx) -> x2
	&threads[curr_thread] -> x0
	
	sp_el0 -> x1
	elr_el1 -> x2

	x1 -> threads[curr_thread].sp
	x2 -> threads[curr_thread].pc
	spsr_el1 -> x1
	x1 -> threads[curr_thread].cpsr	
	x4 ~ x30 -> threads[curr_thread].x[4]~x[30]
	thread_core_local.x[0]~x[3] -> x4 ~ x7
	x4 ~ x7 -> threads[curr_thread].x[0]~x[3]
}
------------------------------------------------
native_old_func:
thread_core_local.flags(stack sp) -> w1
w1 << 4(CLF_SAVED_SHIFT) -> w1
w1 | (1 << 3)(CLF_FIQ) -> w1
w1 | (1 << 0)(CLF_TMP) -> w1
w1 -> thread_core_local.flags(stack sp)

/* load tmp_stack_va_end */
thread_core_local.tmp_stack_va_end(stack sp) -> x1
sp_el0 -> x2

#0 -> spsel 
sp: sp_el0

x1 -> sp (sp_el0: tmp_stack_va_end)

/*
 * Save registers on stack that can be corrupted by a call to
 * a C function
 */

/* Make room for struct elx_nintr_rec */
/*
 * This struct is never used from C it's only here to visualize the
 * layout.
 *
 * struct elx_nintr_rec {
 * 	uint64_t x[19 - 4]; x4..x18
 * 	uint64_t lr;
 * 	uint64_t sp_el0;
 * };
 */

sp - #ELX_NINTR_REC_SIZE -> sp

/* Store x4..x18 */
x[4]~x[18] -> elx_nintr_rec.x[15] (stack sp)

/* Store lr and original sp_el0 */
x30 -> elx_nintr_rec.lr (stack sp)
x2 -> elx_nintr_rec.sp_el0 (stack sp)

bl	thread_check_canaries (stack_tmp)
blr main_fiq (xl6 used)

/*
 * Restore registers
 */
 /* Restore x4..x18 */
elx_nintr_rec.x[15] (stack sp) -> x[4]~x[18] 

/* Load  lr and original sp_el0 */
elx_nintr_rec.lr (stack sp) -> x30
elx_nintr_rec.sp_el0 (stack sp) -> x2

/* Restore SP_El0 */
x2 -> sp(sp_el0)

/* Switch back to SP_EL1 */
#1 -> spsel
sp: sp_el1

/* Update core local flags */
thread_core_local.flags(stack sp) -> w0
w0 >> 4(CLF_SAVED_SHIFT) -> w0
w0 -> thread_core_local.flags(stack sp)

/* Restore x0..x3 */
thread_core_local.x[4](stack sp) -> x[0]~x[3]

/* Return from exception */
eret
------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++
OPTEE Mutex
++++++++++++++++++++++++++++++++++++++++++++++++
struct mutex_head {								\
	struct mutex *tqh_first;		/* first element */		\
	struct mutex **tqh_last;	/* addr of last next element */	\
}

TAILQ_INSERT_TAIL(mutexes, m, link) do {			\
	QUEUEDEBUG_TAILQ_INSERT_TAIL((mutexes), (m), link)		\
	(m)->link.tqe_next = NULL;					\
	(m)->link.tqe_prev = (mutexes)->tqh_last;			\
	*(mutexes)->tqh_last = (m);					\
	(mutexes)->tqh_last = &(m)->link.tqe_next;			\
} while (/* CONSTCOND */0)

++++++++++++++++++++++++++++++++++++++++++++++++
OPTEE enter user mode 
++++++++++++++++++++++++++++++++++++++++++++++++
__test_thread_enter_user_mode:
kerenl: sp_el0

x19: sp_el0
sp->sp_el1
sp_el1: cpu_local
x21: procs[n]

++++++++++++++++++++++++++++++++++++++++++++++++
OPTEE source files structure
++++++++++++++++++++++++++++++++++++++++++++++++
+core
+documentation
+keys
+lib
+mk
+scripts
+ta

++++++++++++++++++++++++++++++++++++++++++++++++
U-boot
++++++++++++++++++++++++++++++++++++++++++++++++
Soc: Tegra
board: NVIDIA Jetson TX2

\arch\arm\cpu\armv8\start.S
------------------------------------------------
_start:
b reset
-> b save_boot_params #允许board保存重要的寄存器

save_boot_params:
#(1) reset SCTRL寄存器，一般不要打开
bl reset_sctrl (CONFIG_SYS_RESET_SCTRL)
【
	currentEL -> sctlr_elx
	sctlr_elx = sctlr_elx & 0xfdffffa
	__asm_invalidate_tlb_all
-------------------------------------------------
reset the SCTRL register at the very beginning of
execution to avoid interference from stale mappings 
set up by early firmware/loaders/etc
-------------------------------------------------
】
#(2) 根据当前的EL级别，配置中断向量、MMU、Endian、i/d Cache等
#可以是在EL3/EL2/EL1
#初始状态：(1) Little Endian (2) MMU Disabled (3) i/dCache Disabled
vectors -> vbar_elx
--------------------------------------------------
vectors: \arch\arm\cpu\armv8\exceptions.S
--------------------------------------------------
EL3: 
(1)set vbar_el3 
(2)set scr_el3 #Enable FP/SIMD 
(3)set cntfrq_el0 #Initialize CNTFRQ

EL2:
(1)set vbar_el2
(2)set cptr_el2 #Enable FP/SIMD

EL1:
(1)set vbar_el1
(2)set cpacr_el1 #Enable FP/SIMD

#(3) 配置ARM的勘误表
#目前只支持Cortex-A57 specific errata
#由CONFIG_ARM_ERRATA_XXX控制，在项目的初期，可以不打开，后续根据实际情况打开
bl	apply_core_errata

--------------------------------------------------
Cache/BPB/TLB失效
i-cache is invalidated before enabled in icache_enable()
tlb is invalidated before mmu is enabled in dcache_enable()
d-cache is invalidated before enabled in dcache_enable()
--------------------------------------------------

#(4) 处理器特定初始化 (lowlevel_init)
#一般情况下，不需要实现
#start.S中也有一个WEAK类型的定义，由CONFIG_GICV2 | CONFIG_GICV3控制，一般情况下，没有打开的必要

bl lowlevel_init
【
	do some work about gic

	# All slaves will enter EL2 and optionally EL1
	bl	armv8_switch_to_el2
	bl	armv8_switch_to_el1 (CONFIG_ARMV8_SWITCH_TO_EL1)

--------------------------------------------------
- purpose: essential init to permit execution to reach board_init_f()
- no global_data or BSS
- there is no stack (ARMv7 may have one but it will soon be removed)
- must not set up SDRAM or use console
- must only do the bare minimum to allow execution to continue to board_init_f()
- this is almost never needed
- return normally from this function
--------------------------------------------------
】

#(5) 如果是多CPU的场景，处理其它的CPU的boot
#多CPU功能由CONFIG_ARMV8_MULTIENTRY控制，不需要打开

#(6) 跳转到arm公共的_main中执行
bl	_main
--------------------------------------------------
_main: \arch\arm\lib\crt0_64.S
--------------------------------------------------

--------------------------------------------------
crt0是C-runtime Startup Code的简称，意思就是运行C代码之前的准备工作
--------------------------------------------------
\arch\arm\lib\crt0_64.S
_main:

#(1) 设置C代码的运行环境，为调用board_init_f接口做准备
#stack and GD both located in some readily available RAM (SRAM, locked cache...)

#(a) 设置堆栈（C代码的函数调用，堆栈是必须的）。如果当前的编译是SPL（由CONFIG_SPL_BUILD定义），可单独定义堆栈基址（CONFIG_SPL_STACK），否则，通过CONFIG_SYS_INIT_SP_ADDR定义堆栈基址
[ ] CONFIG_SPL_STACK -> sp (CONFIG_SPL_BUILD && CONFIG_SPL_STACK)
[*] CONFIG_SYS_INIT_SP_ADDR -> sp

#(b) 调用board_init_f_alloc_reserve接口，从堆栈开始的地方，为u-boot中大名鼎鼎的GD ('global data') 数据结构，分配空间
bl board_init_f_alloc_reserve
【
	sp = sp - CONFIG_SYS_MALLOC_F_LEN (CONFIG_SYS_MALLOC_F)
	sp = sp - sizeof(struct global_data)
--------------------------------------------------
allocate reserved space for use as 'globals' from 'top' address 
and return 'bottom' address of allocated space
struct global_data: include/asm-generic/global_data.h
--------------------------------------------------
】

#(c) 调用board_init_f_init_reserve接口，对GD进行初始化
#将开始地址(就是一个struct global_data指针)保存在一个寄存器中，后续的传递，都是通过保存在寄存器中的指针实现
#对arm64平台来说，该指针保存在了X18寄存器
x0 -> x18
bl	board_init_f_init_reserve
【
	clear GD with zero
	use global data gd
	gd->malloc_base = base (CONFIG_SYS_MALLOC_F)
--------------------------------------------------
initialize reserved space (which has been safely allocated on the C 
stack from the C runtime environment handling code).
--------------------------------------------------
】

#(2) 调用board_init_f函数，完成一些前期的初始化工作
x0 = 0
bl board_init_f (call board_init_f(0))

\common\board_f.c
void board_init_f(ulong boot_flags)
【
	#use the stack here to host global data until relocation
	gd = &data (CONFIG_SYS_GENERIC_GLOBAL_DATA)
	clear gd with zero (CONFIG_SYS_GENERIC_GLOBAL_DATA)
	gd->flags = boot_flags
	gd->have_console = 0
	#遍历运行init_sequence_f函数队列
	initcall_run_list(init_sequence_f)
--------------------------------------------------
prepare the hardware for execution from system RAM (DRAM, DDR...)
use the current GD to store the relocation destination, 
the future stack, and the future GD location
--------------------------------------------------
】
static init_fnc_t init_sequence_f[] = {

	setup_ram_buf, (CONFIG_SANDBOX)
	
	setup_mon_len,
	
	fdtdec_setup, (CONFIG_OF_CONTROL)

	trace_early_init, (CONFIG_TRACE)

	initf_malloc,

	initf_console_record,

	arch_cpu_init,

	mach_cpu_init,

	initf_dm,

	arch_cpu_init_dm,

	board_early_init_f, (CONFIG_BOARD_EARLY_INIT_F)

	init_timebase,

	timer_init, (CONFIG_ARM) important

	get_clocks, (CONFIG_SYS_FSL_CLK || CONFIG_M68K) important

	env_init,

	init_baud_rate, important

	serial_init, important

	console_init_f,

	sandbox_early_getopt_check, (CONFIG_SANDBOX)

	display_options,

	display_text_info,

	print_cpuinfo,

	show_board_info, (CONFIG_DISPLAY_BOARDINFO)

	init_func_watchdog_init, (CONFIG_WATCHDOG || CONFIG_HW_WATCHDOG)

	misc_init_f, (CONFIG_MISC_INIT_F)

	init_func_watchdog_reset, (CONFIG_WATCHDOG || CONFIG_HW_WATCHDOG)

	init_func_i2c, (CONFIG_HARD_I2C || CONFIG_SYS_I2C)

	init_func_spi, (CONFIG_HARD_SPI)

	announce_dram_init,

	dram_init, (CONFIG_ARM) important

	post_init_f, (CONFIG_POST)

	init_func_watchdog_reset,

	testdram, (CONFIG_SYS_DRAM_TEST) 

	init_func_watchdog_reset,

	init_post, (CONFIG_POST)

	init_func_watchdog_reset,

--------------------------------------------------
Now that we have DRAM mapped and working, we can
relocate the code and continue running from DRAM.

Reserve memory at end of RAM for (top down in that order):
- area that won't get touched by U-Boot and Linux (optional)
- kernel log buffer
- protected RAM
- LCD framebuffer
- monitor code
- board info struct
--------------------------------------------------

	setup_dest_addr,

	reserve_uboot, (CONFIG_BLACKFIN || CONFIG_XTENSA)

	reserve_logbuffer, (CONFIG_LOGBUFFER && !CONFIG_ALT_LB_ADDR)

	reserve_pram, (CONFIG_PRAM)

	reserve_round_4k, 

	reserve_mmu, (!(CONFIG_SYS_ICACHE_OFF && CONFIG_SYS_DCACHE_OFF) || CONFIG_ARM)

	reserve_lcd, (CONFIG_LCD)

	reserve_trace,

	reserve_uboot, (!CONFIG_BLACKFIN && !CONFIG_XTENSA)

	reserve_malloc, (CONFIG_SPL_BUILD)

	reserve_board, (CONFIG_SPL_BUILD)

	setup_machine,

	reserve_global_data,

	reserve_fdt,

	reserve_arch,

	reserve_stacks,

	setup_dram_config, important

	show_dram_config,

	display_new_sp,

	setup_board_extra, (CONFIG_SYS_EXTBDINFO)

	init_func_watchdog_reset,

	reloc_fdt,

	setup_reloc, important

	clear_bss, (CONFIG_XTENSA)
}
--------------------------------------------------
#可能和RAM相关
setup_ram_buf:
【
	gd->arch.ram_buf = state->ram_buf
	gd->ram_size = state->ram_size
】
--------------------------------------------------
#sys_monitor_len
setup_mon_len:
【
	set gd->mon_len
】
--------------------------------------------------
#调用fdtdec_setup，配置gd->fdt_blob指针（即device tree所在的存储位置）
#对ARM平台来说，u-boot的Makefile会通过连接脚本，将dtb文件打包到u-boot image的“__dtb_dt_begin”位置处，因此不需要特别关心
fdtdec_setup:
【
	set gd->fdt_blob
】
--------------------------------------------------
#和debug相关？
trace_early_init:
【

】
--------------------------------------------------
#初始化malloc有关的global data
initf_malloc:
【
	gd->malloc_limit = CONFIG_SYS_MALLOC_F_LEN; (CONFIG_SYS_MALLOC_F_LEN)
	gd->malloc_ptr = 0; (CONFIG_SYS_MALLOC_F_LEN)
】 
--------------------------------------------------
initf_console_record:
【
】
--------------------------------------------------
#和具体的cpu相关
#cpu级别的初始化操作
arch_cpu_init:
【
】
--------------------------------------------------
mach_cpu_init:
【
	没有实现
】
--------------------------------------------------
#driver model有关的初始化操作
initf_dm:
【
	#初始化并扫描系统所有的device
	dm_init_and_scan (CONFIG_DM && CONFIG_SYS_MALLOC_F_LEN)
	#初始化driver model所需的timer
	dm_timer_init (CONFIG_TIMER_EARLY)
】
--------------------------------------------------
#record the board_init_f() bootstage
mark_bootstage:
【
】
--------------------------------------------------
#执行板级的early初始化，与具体平台相关
board_early_init_f:
【
】
--------------------------------------------------
#没做啥
init_timebase:
【
】
--------------------------------------------------
#初始化系统的timer
#该接口应该由平台或者板级的代码实现
#初始化成功后，u-boot会通过其它的API获取当前的timestamp
timer_init:
【
】
--------------------------------------------------
#获取当前CPU和BUS的时钟频率，并保存在global data中
#与具体平台相关
get_clocks:
【
	gd->cpu_clk
	gd->bus_clk
】
--------------------------------------------------
#初始化环境变量有关的逻辑，不需要特别关注
env_init:
【
	gd->env_addr
	gd->env_valid
】
--------------------------------------------------
#获取当前使用串口波特率
#可以有两个途径（优先级从高到低）：(1) 从"baudrate"中获取；(2) 从CONFIG_BAUDRATE配置项获取。
init_baud_rate:
【
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
】
--------------------------------------------------
#初始化serial
#包括u-boot serial core以及具体的serial driver
#该函数执行后，系统的串口（特别是用于控制台的）已经可用
serial_init:
【
	gd->flags |= GD_FLG_SERIAL_READY
	get_current()->start()
】
--------------------------------------------------
#初始化系统的控制台，之后串口输出可用
console_init_f:
【
	gd->have_console = 1
	#如果使能，可以通过“silent”环境变量，控制u-boot的控制台是否输出
	console_update_silent (CONFIG_SILENT_CONSOLE)
	print_pre_console_buffer(PRE_CONSOLE_FLUSHPOINT1_SERIAL)
】
--------------------------------------------------
#？
sandbox_early_getopt_check:
【
】
--------------------------------------------------
#通过控制台，显示一些信息，可用于debug
#display
display_options:
【
】
--------------------------------------------------
#display
display_text_info:
【
】
--------------------------------------------------
#display cpu info (and speed)
print_cpuinfo:
【
】
--------------------------------------------------
#init watchdog
init_func_watchdog_init:
【
	#init hw watchdog
	hw_watchdog_init
	#reset watchdog (hardware or software watchdog ?)
	WATCHDOG_RESET
】
--------------------------------------------------
#执行misc driver有关的初始化
misc_init_f:
【
】
--------------------------------------------------
#reset watchdog
init_func_watchdog_reset:
【
	WATCHDOG_RESET
】
--------------------------------------------------
#执行i2c driver有关的初始化
init_func_i2c:
【
	i2c_init
】
--------------------------------------------------
#执行spi driver有关的初始化
init_func_spi:
【
	spi_init
】
--------------------------------------------------
#宣布要进行DDR的初始化
announce_dram_init:
【
】
--------------------------------------------------
#初始化系统的DDR
#dram_init应该由平台相关的代码实现
dram_init:
【
	gd->ram_size
】
--------------------------------------------------
#和post_time_ms有关
post_init_f:
【
	gd->post_init_f_time
】
--------------------------------------------------
#reset watchdog
init_func_watchdog_reset:
【
】
--------------------------------------------------
#执行DDR的测试操作
#可以在开发阶段打开，系统稳定后关闭
testdram:
【
】
--------------------------------------------------
init_post:
【
】
--------------------------------------------------
setup_dest_addr:
【
	gd->ram_size
	gd->ram_top
	gd->relocaddr
】
--------------------------------------------------
#reserve memory for U-Boot code, data & bss
reserve_uboot:
【
	gd->relocaddr
	gd->start_addr_sp
】
--------------------------------------------------
#reserve kernel log buffer
reserve_logbuffer:
【
	gd->relocaddr
】
--------------------------------------------------
#reserve protected RAM
reserve_pram:
【
	gd->relocaddr
】
--------------------------------------------------
#round memory pointer down to next 4 kB limit
reserve_round_4k:
【
	gd->relocaddr
】
--------------------------------------------------
#reserve TLB table
reserve_mmu:
【
	gd->arch.tlb_size
	gd->relocaddr
	gd->arch.tlb_addr
】
--------------------------------------------------
#reserve memory for LCD display (always full pages)
reserve_lcd:
【
	gd->relocaddr
	gd->fb_base
】
--------------------------------------------------
reserve_trace:
【
	gd->relocaddr
	gd->trace_buff
】
--------------------------------------------------
#reserve memory for malloc() area
reserve_malloc:
【
	gd->start_addr_sp
】
--------------------------------------------------
#(permanently) allocate a Board Info struct
reserve_board:
【
	gd->start_addr_sp
	gd->bd
】
--------------------------------------------------
#board id for Linux 
setup_machine:
【
	gd->bd->bi_arch_number
】
--------------------------------------------------
reserve_global_data:
【
	gd->start_addr_sp
	gd->new_gd
】
--------------------------------------------------
#if the device tree is sitting immediately above our image 
#then we must relocate it.
#if it is embedded in the data section, then it will be 
#relocated with other data
reserve_fdt:
【
	gd->fdt_size
	gd->start_addr_sp
	gd->new_fdt
】
--------------------------------------------------
#architecture-specific memory reservation
reserve_arch:
【
】
--------------------------------------------------
#reserve stacks
reserve_stacks:
【
	gd->irq_sp
	gd->start_addr_sp
】
--------------------------------------------------
1）考虑到后续的kernel是在RAM的低端位置解压缩并执行的，
为了避免麻烦，u-boot将使用DRAM的顶端地址，即gd->ram_top所代表的位置
其中gd->ram_top是由setup_dest_addr函数配置的
2）u-boot所使用的DRAM，主要分为三类：
各种特殊功能所需的空间，如log buffer、MMU page table、LCD fb buffer、trace buffer等等
u-boot的代码段、数据段、BSS段所占用的空间（就是u-boot relocate之后的执行空间），由gd->relocaddr标示
堆栈空间，从gd->start_addr_sp处递减
3）特殊功能以及u-boot所需空间，是由reserve_xxx系列函数保留的
4）reserve空间分配完毕后，堆栈紧随其后，递减即可
--------------------------------------------------
#u-boot中DRAM的使用情况

+++++++++++++++++++++++++++++++ ------------------gd->ram_top
+ logbuffer                   + reserve_logbuffer
+ (LOGBUFF_RESERVE)           +
+++++++++++++++++++++++++++++++
+ protected RAM               + reserve_pram
+ (pram env or CONFIG_PRAM)   +
+++++++++++++++++++++++++++++++
+ round to 4K                 + reserve_round_4k
+++++++++++++++++++++++++++++++
+ MMU                         + reserve_mmu
+ (PGTABLE_SIZE,round to 64KB)+
+++++++++++++++++++++++++++++++
+ LCD fb buffer               + reserve_lcd
+++++++++++++++++++++++++++++++
+ Trace buffer                + reserve_trace
+ (CONFIG_TRACE_BUFFER_SIZE)  +
+++++++++++++++++++++++++++++++
+ U-Boot code, data & bss     + reserve_uboot
+++++++++++++++++++++++++++++++ ------------------gd->relocaddr
+ malloc() area               + reserve_malloc
+ (TOTAL_MALLOC_LEN)          +
+++++++++++++++++++++++++++++++
+ Board Info struct           + reserve_board
+ (sizeof(bd_t))              +
+++++++++++++++++++++++++++++++
+ new global data             + reserve_global_data
+++++++++++++++++++++++++++++++
+ new fdt (device tree)       + reserve_fdt
+++++++++++++++++++++++++++++++
+ arch-special memory         + reserve_arch
+++++++++++++++++++++++++++++++
+ arch-special stacks         + reserve_stacks
+++++++++++++++++++++++++++++++ ------------------gd->start_addr_sp
+                             +
+                             +
+                             +
+                             +
+++++++++++++++++++++++++++++++
--------------------------------------------------
#调用dram_init_banksize接口（由具体的平台代码实现）
#初始化DDR的bank信息
setup_dram_config:
【
	gd->bd->bi_dram[i]
】
--------------------------------------------------
show_dram_config:
【
】
--------------------------------------------------
display_new_sp:
【
】
--------------------------------------------------
setup_board_extra:
【
	bd->bi_procfreq
	bd->bi_plb_busfreq
】
--------------------------------------------------
#将device tree拷贝到new_fdt所在的位置，也就是device tree的relocation操作
reloc_fdt:
【
	memcpy(gd->new_fdt, gd->fdt_blob, gd->fdt_size)
	gd->fdt_blob = gd->new_fdt
】
--------------------------------------------------
#CONFIG_SYS_TEXT_BASE是u-boot relocation之前在（只读）memory的位置（也是编译时指定的位置），gd->relocaddr是relocation之后的位置，因此gd->reloc_off代表u-boot relocation操作之后的偏移量，后面relocation时会用到
#global data的relocation
setup_reloc:
【
	gd->reloc_off = gd->relocaddr - CONFIG_SYS_TEXT_BASE
	memcpy(gd->new_gd, (char *)gd, sizeof(gd_t))
】
--------------------------------------------------
clear_bss:
【
】
--------------------------------------------------